# 缓存
Web缓存是可以自动保存常见文档副本的HTTP设备。

## 1 缓存概念

### 1.1 缓存作用

1. 缓存减少了冗余的数据传输，节省了网络费用；
2. 缓解了网络瓶颈的问题，不需要更多的带宽就能够更快地加载页面；
3. 降低了对原始服务器的要求，服务器可以更快地响应，避免过载的出现；
4. 降低了距离时延，因为从较远的地方加载页面会更慢一些。

### 1.2 缓存必要性

1. 冗余的数据传输

多个客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传送给一个客户端。一些相同的字节会在网络中一遍遍地传输。    
这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重Web服务器的负载。    
有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少那些流入/流出原始服务器的，被浪费掉了的重复流量。    

2. 带宽瓶颈 
缓存还可以缓解网络的瓶颈问题。很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。     
如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能——尤其是要传输比较大的文件时。    

3. 瞬间拥塞 
缓存在破坏瞬间拥塞(Flash Crowds)时显得非常重要。突发事件(比如爆炸性新闻、批量E-mail公告，或者某个名人事件)使很多人几乎同时去访问一个Web文档时，就会出现瞬间拥塞。造成网络和Web服务器产生灾难性的崩溃。        

4. 距离时延 
每台网络路由器都会增加因特网流量的时延。即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著的时延。    

 
### 1.3 缓存命中
缓存**无法保存世界上每份文档的副本**。
可以用已有的副本为某些到达缓存的请求提供服务，这被称为缓存命中(cache hit)。   
其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为缓存未命中(cache miss)。  


### 1.4 缓存再验证
缓存可以在**任意时刻**，以**任意频率**对副本进行**再验证**。
但由于缓存通常会包含数百万的文档，而且网络带宽是很珍贵的，所以大部分缓存只有**在客户端发起请求**，并且**副本旧得足以需要检测**的时候，才会对副本进行再验证。


### 1.4.1 缓存再验证过程
缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。        
只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端，这被称作再验证命中(revalidate hit)或缓慢命中(slow hit)。        
这种方式确实要与原始服务器进行核对，所以会比单纯的缓存命中要慢，但它没有从服务器中获取对象数据，所以要比缓存未命中快一些。         
 

### 1.4.2 缓存再验证方法
HTTP提供了几个用来对已缓存对象进行再验证的工具，但**最常用的是If-Modified-Since首部**。  
将这个首部添加到GET请求中去，就可以告诉服务器，只有在**缓存了对象的副本**之后，**又对其进行了修改**的情况下，才发送此对象。
 
服务器收到GET If-Modified-Since请求时会发生的情况：   
- 再验证命中——如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP **304 Not Modified响应**；
- 再验证未命中——如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP **200 0K响应**；
- 对象被删除——如果服务器对象已经被删除了，服务器就回送一个**404 Not Found响应**，缓存也会将其副本删除

### 1.5 命中率
由缓存提供服务的请求所占的比例被称为缓存命中率(cache hit rate,或称为缓存命中比例)，有时也被称为文档命中率(document hit rate)。命中率在0到1之间，但通常是用百分数来描述的。

命中率很难预测，但对现在中等规模的Web缓存来说，40%的命中率是很合理的。

1. 字节命中率
由于文档并不全是同一尺寸的，所以文档命中率并不能说明一切。
有些大型对象被访问的次数可能较少，但由于尺寸的原因，对整个数据流量的贡献却更大。因此，有些人更愿意使用字节命中率(byte hit rate)作为度量值(尤其那些按流量字节付费的人)。

2. 区分命中和未命中

幸的是，**HTTP没有**为用户提供一种手段来区分响应是缓存命中的，还是访问原始服务器得到的。
在这两种情况下，响应码都是200 OK，说明响应有主体部分。
有些商业代理缓存会在Via首部附加一些额外信息，以描述缓存中发生的情况。
客户端有一种方法可以判断响应是否来自缓存，就是使用Date首部(报文创建的日期和时间)。将响应中Date首部的值与当前时间进行比较，如果响应中的日期值比较早，客户端通常就可以认为这是一条缓存的响应。
客户端也可以通过Age首部（响应首部,表示代理服务器当前的系统时间与此应答消息中的通用消息头 Date 的值之差）来检测缓存的响应，通过这个首部可以分辨出这条响应的使用期.




缓存

1. 可缓存性：
public
private

2. 到期：

max-age=<seconds>
s-maxage=<seconds>
max-stale=<seconds>

3. 重新验证：
must-revalidate
proxy-revalidate

4. 其他
no-cache
no-store
no-transform

5. 验证
Last-Modified, 配合If-Modified-Since/ If-UnModified-Since
Etag, 配合If-Match和If-Non-Match


Cookie
通过Set-Cookie设置
下次请求自动带上
键值对，可以设置多个

Cookie 属性
max-age 和expires 设置过期时间
Secure 只在https的时候发送
HttpOnly设置后，无法通过js 的document.cookie访问








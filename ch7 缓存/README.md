# 缓存
Web缓存是可以自动保存常见文档副本的HTTP设备。

## 1 缓存概念

### 1.1 缓存作用

1. 缓存减少了冗余的数据传输，节省了网络费用；
2. 缓解了网络瓶颈的问题，不需要更多的带宽就能够更快地加载页面；
3. 降低了对原始服务器的要求，服务器可以更快地响应，避免过载的出现；
4. 降低了距离时延，因为从较远的地方加载页面会更慢一些。

### 1.2 缓存必要性

1. 冗余的数据传输

多个客户端访问一个流行的原始服务器页面时，服务器会多次传输同一份文档，每次传送给一个客户端。一些相同的字节会在网络中一遍遍地传输。    
这些冗余的数据传输会耗尽昂贵的网络带宽，降低传输速度，加重Web服务器的负载。    
有了缓存，就可以保留第一条服务器响应的副本，后继请求就可以由缓存的副本来应对了，这样可以减少那些流入/流出原始服务器的，被浪费掉了的重复流量。    

2. 带宽瓶颈 
缓存还可以缓解网络的瓶颈问题。很多网络为本地网络客户端提供的带宽比为远程服务器提供的带宽要宽。客户端会以路径上最慢的网速访问服务器。     
如果客户端从一个快速局域网的缓存中得到了一份副本，那么缓存就可以提高性能——尤其是要传输比较大的文件时。    

3. 瞬间拥塞 
缓存在破坏瞬间拥塞(Flash Crowds)时显得非常重要。突发事件(比如爆炸性新闻、批量E-mail公告，或者某个名人事件)使很多人几乎同时去访问一个Web文档时，就会出现瞬间拥塞。造成网络和Web服务器产生灾难性的崩溃。        

4. 距离时延 
每台网络路由器都会增加因特网流量的时延。即使客户端和服务器之间没有太多的路由器，光速自身也会造成显著的时延。    

 
### 1.3 缓存命中
缓存**无法保存世界上每份文档的副本**。
可以用已有的副本为某些到达缓存的请求提供服务，这被称为缓存命中(cache hit)。   
其他一些到达缓存的请求可能会由于没有副本可用，而被转发给原始服务器。这被称为缓存未命中(cache miss)。  


### 1.4 缓存再验证
缓存可以在**任意时刻**，以**任意频率**对副本进行**再验证**。
但由于缓存通常会包含数百万的文档，而且网络带宽是很珍贵的，所以大部分缓存只有**在客户端发起请求**，并且**副本旧得足以需要检测**的时候，才会对副本进行再验证。


### 1.4.1 缓存再验证过程
缓存对缓存的副本进行再验证时，会向原始服务器发送一个小的再验证请求。如果内容没有变化，服务器会以一个小的304 Not Modified进行响应。        
只要缓存知道副本仍然有效，就会再次将副本标识为暂时新鲜的，并将副本提供给客户端，这被称作再验证命中(revalidate hit)或缓慢命中(slow hit)。        
这种方式确实要与原始服务器进行核对，所以会比单纯的缓存命中要慢，但它没有从服务器中获取对象数据，所以要比缓存未命中快一些。         
 

### 1.4.1 缓存再验证方法
HTTP提供了几个用来对已缓存对象进行再验证的工具，但**最常用的是If-Modified-Since首部**。  
将这个首部添加到GET请求中去，就可以告诉服务器，只有在**缓存了对象的副本**之后，**又对其进行了修改**的情况下，才发送此对象。
 
服务器收到GET If-Modified-Since请求时会发生的情况：   
- 再验证命中——如果服务器对象未被修改，服务器会向客户端发送一个小的HTTP **304 Not Modified响应**；
- 再验证未命中——如果服务器对象与已缓存副本不同，服务器向客户端发送一条普通的、带有完整内容的HTTP **200 0K响应**；
- 对象被删除——如果服务器对象已经被删除了，服务器就回送一个**404 Not Found响应**，缓存也会将其副本删除





























  